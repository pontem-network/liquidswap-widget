import { IPersistedPool } from '../types/pools';
import { TVersionType } from '../types';
export declare const usePoolsStore: import("pinia").StoreDefinition<"poolsStore", import("pinia")._UnwrapAll<Pick<{
    isLoading: import("vue").Ref<boolean>;
    isReady: import("vue").Ref<boolean>;
    getPool: import("vue").ComputedRef<(coinX: string, coinY: string, curve: string, contract?: TVersionType) => Promise<IPersistedPool>>;
    getCurveType: (coinX?: string, coinY?: string, version?: number) => string | false;
    fetchPoolsList: () => Promise<void>;
    pools: import("vue").Ref<{
        title: string;
        reserveX: number;
        reserveY: number;
        addedX: number;
        addedY: number;
        lp: number;
        isDefault: boolean;
        apr?: number | undefined;
        coinX: string;
        coinY: string;
        curve: string;
        networkId: number;
        contract?: TVersionType | undefined;
    }[]>;
    poolsMap: Record<string, IPersistedPool>;
    poolsTitleMap: Record<string, string>;
    defaultPools: import("vue").ComputedRef<IPersistedPool[]>;
    poolsMapAsArray: import("vue").ComputedRef<IPersistedPool[]>;
}, "isReady" | "isLoading" | "pools" | "poolsMap" | "poolsTitleMap">>, Pick<{
    isLoading: import("vue").Ref<boolean>;
    isReady: import("vue").Ref<boolean>;
    getPool: import("vue").ComputedRef<(coinX: string, coinY: string, curve: string, contract?: TVersionType) => Promise<IPersistedPool>>;
    getCurveType: (coinX?: string, coinY?: string, version?: number) => string | false;
    fetchPoolsList: () => Promise<void>;
    pools: import("vue").Ref<{
        title: string;
        reserveX: number;
        reserveY: number;
        addedX: number;
        addedY: number;
        lp: number;
        isDefault: boolean;
        apr?: number | undefined;
        coinX: string;
        coinY: string;
        curve: string;
        networkId: number;
        contract?: TVersionType | undefined;
    }[]>;
    poolsMap: Record<string, IPersistedPool>;
    poolsTitleMap: Record<string, string>;
    defaultPools: import("vue").ComputedRef<IPersistedPool[]>;
    poolsMapAsArray: import("vue").ComputedRef<IPersistedPool[]>;
}, "getPool" | "defaultPools" | "poolsMapAsArray">, Pick<{
    isLoading: import("vue").Ref<boolean>;
    isReady: import("vue").Ref<boolean>;
    getPool: import("vue").ComputedRef<(coinX: string, coinY: string, curve: string, contract?: TVersionType) => Promise<IPersistedPool>>;
    getCurveType: (coinX?: string, coinY?: string, version?: number) => string | false;
    fetchPoolsList: () => Promise<void>;
    pools: import("vue").Ref<{
        title: string;
        reserveX: number;
        reserveY: number;
        addedX: number;
        addedY: number;
        lp: number;
        isDefault: boolean;
        apr?: number | undefined;
        coinX: string;
        coinY: string;
        curve: string;
        networkId: number;
        contract?: TVersionType | undefined;
    }[]>;
    poolsMap: Record<string, IPersistedPool>;
    poolsTitleMap: Record<string, string>;
    defaultPools: import("vue").ComputedRef<IPersistedPool[]>;
    poolsMapAsArray: import("vue").ComputedRef<IPersistedPool[]>;
}, "getCurveType" | "fetchPoolsList">>;
